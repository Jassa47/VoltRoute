<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PROJECT_STRUCTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PROJECT_STRUCTURE.md" />
              <option name="updatedContent" value="# VoltRoute - Complete Project Structure&#10;&#10;## Directory Tree&#10;&#10;```&#10;VoltRoute/&#10;│&#10;├──  PHASE_2_COMPLETION_SUMMARY.md ← Read this first!&#10;├──  TESTING_GUIDE.md ← Quick start guide&#10;├──  build.gradle.kts&#10;├──  settings.gradle.kts&#10;├──  local.properties (MAPS_API_KEY=...)&#10;│&#10;├── gradle/&#10;│   └── libs.versions.toml (dependencies)&#10;│&#10;└── app/&#10;    ├──  build.gradle.kts&#10;    │   • buildConfig = true&#10;    │   • secrets plugin&#10;    │&#10;    └── src/main/&#10;        ├──  AndroidManifest.xml&#10;        │&#10;        └── java/com/example/voltroute/&#10;            │&#10;            ├──  MainActivity.kt&#10;            │   └── @AndroidEntryPoint&#10;            │&#10;            ├──  VoltRouteApplication.kt&#10;            │   └── @HiltAndroidApp&#10;            │&#10;            ├──  data/&#10;            │   │&#10;            │   ├── location/&#10;            │   │   └──  LocationClient.kt&#10;            │   │       • FusedLocationProvider&#10;            │   │       • @Singleton&#10;            │   │&#10;            │   └── remote/&#10;            │       │&#10;            │       ├── api/&#10;            │       │   └──  DirectionsApi.kt ✨ NEW&#10;            │       │       • Retrofit interface&#10;            │       │       • GET /maps/api/directions/json&#10;            │       │&#10;            │       ├── dto/&#10;            │       │   └──  DirectionsResponse.kt ✨ NEW&#10;            │       │       • DirectionsResponse&#10;            │       │       • RouteDto&#10;            │       │       • LegDto, DistanceDto, DurationDto&#10;            │       │       • PolylineDto, LocationDto&#10;            │       │       • @SerializedName for JSON&#10;            │       │&#10;            │       └── repository/&#10;            │           └── ️ RouteRepository.kt ✨ NEW&#10;            │               • Calls DirectionsApi&#10;            │               • Maps DTOs → Domain models&#10;            │               • Error handling (status codes)&#10;            │               • Returns Result&lt;Route&gt;&#10;            │               • @Singleton&#10;            │&#10;            ├──  domain/&#10;            │   │&#10;            │   ├── model/&#10;            │   │   │&#10;            │   │   ├──  Location.kt&#10;            │   │   │   • lat, lng, name&#10;            │   │   │   • DEFAULT companion&#10;            │   │   │&#10;            │   │   ├──  Vehicle.kt&#10;            │   │   │   • batteryCapacityKWh (135.0)&#10;            │   │   │   • efficiencyKWhPerKm (0.18)&#10;            │   │   │   • currentBatteryPercent (80.0)&#10;            │   │   │   • Computed: currentEnergyKWh&#10;            │   │   │   • Computed: remainingRangeKm&#10;            │   │   │&#10;            │   │   └── ️ Route.kt ✨ NEW&#10;            │   │       • distanceMeters, durationSeconds&#10;            │   │       • polylinePoints&#10;            │   │       • startLocation, endLocation&#10;            │   │       • Computed: distanceKm, durationMinutes&#10;            │   │       • Computed: distanceText, durationText&#10;            │   │&#10;            │   └── usecase/&#10;            │       └──  CalculateRouteUseCase.kt ✨ NEW&#10;            │           • operator fun invoke()&#10;            │           • Validates destination&#10;            │           • Calls RouteRepository&#10;            │           • Returns Result&lt;Route&gt;&#10;            │&#10;            ├──  di/&#10;            │   └──  AppModule.kt ✨ NEW&#10;            │       • @Module @InstallIn(SingletonComponent)&#10;            │       • Provides @Named(&quot;maps_api_key&quot;)&#10;            │       • Provides OkHttpClient (logging)&#10;            │       • Provides Retrofit (Gson)&#10;            │       • Provides DirectionsApi&#10;            │       • All @Singleton&#10;            │&#10;            ├──  presentation/&#10;            │   └── map/&#10;            │       │&#10;            │       ├──  MapScreen.kt ✨ UPDATED&#10;            │       │   • GoogleMap with Polyline&#10;            │       │   • Current location marker&#10;            │       │   • Destination marker (red)&#10;            │       │   • DestinationInput card&#10;            │       │   • &quot;Calculate Route&quot; button&#10;            │       │   • &quot;Clear Route&quot; button&#10;            │       │   • RouteInfoCard at bottom&#10;            │       │   • Loading indicators&#10;            │       │   • Error snackbars&#10;            │       │   • Camera animations (bounds)&#10;            │       │&#10;            │       ├──  MapViewModel.kt ✨ UPDATED&#10;            │       │   • @HiltViewModel&#10;            │       │   • Injects: LocationClient, CalculateRouteUseCase&#10;            │       │   • StateFlow&lt;MapUiState&gt;&#10;            │       │   • StateFlow&lt;Vehicle&gt;&#10;            │       │   • Functions:&#10;            │       │       - checkLocationPermission()&#10;            │       │       - getCurrentLocation()&#10;            │       │       - onDestinationChanged()&#10;            │       │       - calculateRoute() ✨ NEW&#10;            │       │       - clearRoute() ✨ NEW&#10;            │       │       - clearRouteError() ✨ NEW&#10;            │       │       - clearError()&#10;            │       │   • MapUiState:&#10;            │       │       - currentLocation&#10;            │       │       - destinationAddress&#10;            │       │       - hasLocationPermission&#10;            │       │       - isLoadingLocation&#10;            │       │       - locationError&#10;            │       │       - route ✨ NEW&#10;            │       │       - isCalculatingRoute ✨ NEW&#10;            │       │       - routeError ✨ NEW&#10;            │       │       - routePoints: List&lt;LatLng&gt; ✨ NEW&#10;            │       │&#10;            │       └── components/&#10;            │           │&#10;            │           ├── ⌨️ DestinationInput.kt&#10;            │           │   • OutlinedTextField&#10;            │           │   • Search icon&#10;            │           │&#10;            │           └──  RouteInfoCard.kt ✨ NEW&#10;            │               • Material Design 3 Card&#10;            │               • Elevation 8.dp&#10;            │               • Distance + Duration&#10;            │               • DirectionsCar + Schedule icons&#10;            │               • Vertical divider&#10;            │               • SpaceEvenly layout&#10;            │&#10;            └──  ui/theme/&#10;                ├── Color.kt&#10;                ├── Theme.kt&#10;                └── Type.kt&#10;&#10;```&#10;&#10;## Data Flow Architecture&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────┐&#10;│                       PRESENTATION LAYER                      │&#10;├─────────────────────────────────────────────────────────────┤&#10;│                                                               │&#10;│  MapScreen.kt (Composable UI)                                 │&#10;│    ↓                                                          │&#10;│  MapViewModel.kt (@HiltViewModel)                             │&#10;│    • StateFlow&lt;MapUiState&gt;                                    │&#10;│    • calculateRoute() → CalculateRouteUseCase                 │&#10;│                                                               │&#10;└────────────────────────┬──────────────────────────────────────┘&#10;                         │&#10;                         ↓&#10;┌─────────────────────────────────────────────────────────────┐&#10;│                        DOMAIN LAYER                          │&#10;├─────────────────────────────────────────────────────────────┤&#10;│                                                               │&#10;│  CalculateRouteUseCase.kt                                     │&#10;│    • Validates input                                          │&#10;│    • operator fun invoke() → RouteRepository                  │&#10;│                                                               │&#10;│  Models:                                                      │&#10;│    • Location (lat, lng, name)                                │&#10;│    • Route (distance, duration, polyline, locations)         │&#10;│    • Vehicle (battery, efficiency, range)                     │&#10;│                                                               │&#10;└────────────────────────┬──────────────────────────────────────┘&#10;                         │&#10;                         ↓&#10;┌─────────────────────────────────────────────────────────────┐&#10;│                         DATA LAYER                           │&#10;├─────────────────────────────────────────────────────────────┤&#10;│                                                               │&#10;│  RouteRepository.kt (@Singleton)                              │&#10;│    • Calls DirectionsApi                                      │&#10;│    • Maps DTOs → Domain models                                │&#10;│    • Returns Result&lt;Route&gt;                                    │&#10;│    ↓                                                          │&#10;│  DirectionsApi.kt (Retrofit interface)                        │&#10;│    • suspend fun getDirections()                              │&#10;│    ↓                                                          │&#10;│   Google Directions API                                     │&#10;│    • https://maps.googleapis.com/maps/api/directions/json    │&#10;│    ↓                                                          │&#10;│  DirectionsResponse.kt (DTOs)                                 │&#10;│    • JSON → Kotlin data classes                               │&#10;│                                                               │&#10;└─────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;## Dependency Injection (Hilt)&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────┐&#10;│                         AppModule.kt                         │&#10;│                  @InstallIn(SingletonComponent)               │&#10;├─────────────────────────────────────────────────────────────┤&#10;│                                                               │&#10;│  Provides:                                                    │&#10;│    ┌──────────────────────────────────────────┐              │&#10;│    │ @Named(&quot;maps_api_key&quot;): String           │              │&#10;│    │   └─ BuildConfig.MAPS_API_KEY            │              │&#10;│    └──────────────────────────────────────────┘              │&#10;│                  ↓                                            │&#10;│    ┌──────────────────────────────────────────┐              │&#10;│    │ OkHttpClient                              │              │&#10;│    │   • HttpLoggingInterceptor                │              │&#10;│    │   • 30s timeouts                          │              │&#10;│    └──────────────────────────────────────────┘              │&#10;│                  ↓                                            │&#10;│    ┌──────────────────────────────────────────┐              │&#10;│    │ Retrofit                                  │              │&#10;│    │   • Base URL: maps.googleapis.com         │              │&#10;│    │   • GsonConverterFactory                  │              │&#10;│    └──────────────────────────────────────────┘              │&#10;│                  ↓                                            │&#10;│    ┌──────────────────────────────────────────┐              │&#10;│    │ DirectionsApi                             │              │&#10;│    │   └─ retrofit.create()                    │              │&#10;│    └──────────────────────────────────────────┘              │&#10;│                                                               │&#10;└─────────────────────────────────────────────────────────────┘&#10;             │                        │&#10;             ↓                        ↓&#10;    ┌────────────────┐      ┌─────────────────────┐&#10;    │ RouteRepository│      │ MapViewModel        │&#10;    │  @Singleton    │      │  @HiltViewModel     │&#10;    └────────────────┘      └─────────────────────┘&#10;             │                        │&#10;             ↓                        ↓&#10;    ┌──────────────────────┐  ┌──────────────────┐&#10;    │ CalculateRouteUseCase│  │ LocationClient   │&#10;    └──────────────────────┘  │   @Singleton     │&#10;                              └──────────────────┘&#10;```&#10;&#10;## State Management Flow&#10;&#10;```&#10;User Action → ViewModel → StateFlow → UI Update&#10;&#10;Example: Calculate Route&#10;┌──────────────────────────────────────────────────────────────┐&#10;│                                                                │&#10;│  1. User types &quot;San Francisco, CA&quot;                            │&#10;│     ↓                                                          │&#10;│  2. MapScreen calls: viewModel.onDestinationChanged()          │&#10;│     ↓                                                          │&#10;│  3. ViewModel updates: _uiState.update {                       │&#10;│         it.copy(destinationAddress = &quot;San Francisco, CA&quot;)      │&#10;│     }                                                          │&#10;│     ↓                                                          │&#10;│  4. User clicks &quot;Calculate Route&quot;                              │&#10;│     ↓                                                          │&#10;│  5. MapScreen calls: viewModel.calculateRoute()                │&#10;│     ↓                                                          │&#10;│  6. ViewModel:                                                 │&#10;│     a) Sets isCalculatingRoute = true                          │&#10;│     b) Calls calculateRouteUseCase()                           │&#10;│     c) UseCase validates &amp; calls repository                    │&#10;│     d) Repository calls DirectionsApi                          │&#10;│     e) API returns DirectionsResponse                          │&#10;│     f) Repository maps DTO → Route                             │&#10;│     g) Result.success(route) returned                          │&#10;│     h) ViewModel decodes polyline with PolyUtil                │&#10;│     i) Updates: route, routePoints, isCalculatingRoute=false   │&#10;│     ↓                                                          │&#10;│  7. StateFlow emits new MapUiState                             │&#10;│     ↓                                                          │&#10;│  8. MapScreen recomposes with new state                        │&#10;│     • Polyline appears                                         │&#10;│     • RouteInfoCard shows                                      │&#10;│     • Camera animates to bounds                                │&#10;│                                                                │&#10;└──────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;## Key Technologies&#10;&#10;| Technology | Version | Purpose |&#10;|-----------|---------|---------|&#10;| Kotlin | 2.0.21 | Programming language |&#10;| Jetpack Compose | 2024.09 | Declarative UI |&#10;| Material Design 3 | Latest | UI components |&#10;| Hilt | 2.52 | Dependency injection |&#10;| Retrofit | 2.11.0 | HTTP client |&#10;| OkHttp | 4.12.0 | Network logging |&#10;| Gson | Latest | JSON parsing |&#10;| Coroutines | 1.9.0 | Async operations |&#10;| StateFlow | Latest | Reactive state |&#10;| Google Maps Compose | 6.2.1 | Map UI |&#10;| PolyUtil | Included | Polyline decoding |&#10;| Play Services | 21.3.0 | Location services |&#10;&#10;## Build Configuration&#10;&#10;```kotlin&#10;// app/build.gradle.kts&#10;android {&#10;    compileSdk = 36&#10;    minSdk = 26&#10;    targetSdk = 36&#10;    &#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true  // For MAPS_API_KEY&#10;    }&#10;}&#10;&#10;// Plugins&#10;plugins {&#10;    kotlin(&quot;android&quot;)&#10;    kotlin(&quot;kapt&quot;)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;    id(&quot;com.google.android.libraries.mapsplatform.secrets-gradle-plugin&quot;)&#10;}&#10;```&#10;&#10;## File Statistics&#10;&#10;- **Total new files:** 9&#10;- **Updated files:** 2&#10;- **Lines of code added:** ~1,200&#10;- **Packages created:** 3 (remote/api, remote/dto, remote/repository)&#10;&#10;## Next Phase Preview&#10;&#10;**Phase 3: Battery Consumption Estimation**&#10;- Calculate energy usage based on distance&#10;- Show battery level after trip&#10;- Warn if destination unreachable&#10;- Battery consumption visualization&#10;&#10;---&#10;&#10;✅ **Phase 2 Complete!** All files created and tested.&#10;&#10; **Ready to build:** `./gradlew assembleDebug`&#10;&#10; **Ready to run:** Click the Run button in Android Studio&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/voltroute/presentation/map/MapScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/voltroute/presentation/map/MapScreen.kt" />
              <option name="originalContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.example.voltroute.presentation.map&#10;&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Navigation&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.voltroute.presentation.map.components.DestinationInput&#10;import com.example.voltroute.presentation.map.components.EvDashboard&#10;import com.example.voltroute.presentation.map.components.RouteInfoCard&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.LatLngBounds&#10;import com.google.maps.android.compose.*&#10;&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val vehicle by viewModel.vehicle.collectAsState()&#10;&#10;    // Request location permission&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        viewModel.onPermissionResult(isGranted)&#10;    }&#10;&#10;    // Request permission on first composition if not granted&#10;    LaunchedEffect(uiState.hasLocationPermission) {&#10;        if (!uiState.hasLocationPermission) {&#10;            permissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        }&#10;    }&#10;&#10;    // Camera position for map&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            LatLng(uiState.currentLocation.latitude, uiState.currentLocation.longitude),&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Update camera when location changes (only if no route is displayed)&#10;    LaunchedEffect(uiState.currentLocation) {&#10;        if (uiState.route == null) {&#10;            cameraPositionState.position = CameraPosition.fromLatLngZoom(&#10;                LatLng(uiState.currentLocation.latitude, uiState.currentLocation.longitude),&#10;                12f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Update camera to show full route when calculated&#10;    LaunchedEffect(uiState.route) {&#10;        uiState.route?.let { route -&gt;&#10;            if (uiState.routePoints.isNotEmpty()) {&#10;                // Create bounds that include all route points&#10;                val boundsBuilder = LatLngBounds.Builder()&#10;                uiState.routePoints.forEach { point -&gt;&#10;                    boundsBuilder.include(point)&#10;                }&#10;                val bounds = boundsBuilder.build()&#10;&#10;                // Animate camera to show full route with padding&#10;                val cameraUpdate = CameraUpdateFactory.newLatLngBounds(bounds, 100)&#10;                cameraPositionState.animate(cameraUpdate, 1000)&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;VoltRoute&quot;) },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Google Map&#10;            GoogleMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                cameraPositionState = cameraPositionState,&#10;                properties = MapProperties(&#10;                    isMyLocationEnabled = uiState.hasLocationPermission&#10;                ),&#10;                uiSettings = MapUiSettings(&#10;                    zoomControlsEnabled = false,&#10;                    myLocationButtonEnabled = true&#10;                )&#10;            ) {&#10;                // Current location marker&#10;                if (uiState.hasLocationPermission) {&#10;                    Marker(&#10;                        state = rememberMarkerState(&#10;                            position = LatLng(&#10;                                uiState.currentLocation.latitude,&#10;                                uiState.currentLocation.longitude&#10;                            )&#10;                        ),&#10;                        title = &quot;Current Location&quot;&#10;                    )&#10;                }&#10;&#10;                // Route polyline&#10;                if (uiState.routePoints.isNotEmpty()) {&#10;                    Polyline(&#10;                        points = uiState.routePoints,&#10;                        color = Color(0xFF2196F3), // Material Blue&#10;                        width = 12f&#10;                    )&#10;                }&#10;&#10;                // Destination marker&#10;                uiState.route?.let { route -&gt;&#10;                    Marker(&#10;                        state = rememberMarkerState(&#10;                            position = LatLng(&#10;                                route.endLocation.latitude,&#10;                                route.endLocation.longitude&#10;                            )&#10;                        ),&#10;                        title = &quot;Destination&quot;,&#10;                        snippet = route.endLocation.name,&#10;                        icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Destination input overlay&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.TopCenter)&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(8.dp)&#10;                    ) {&#10;                        DestinationInput(&#10;                            value = uiState.destinationAddress,&#10;                            onValueChange = viewModel::onDestinationChanged,&#10;                            enabled = uiState.hasLocationPermission&#10;                        )&#10;&#10;                        // Calculate Route button&#10;                        if (uiState.destinationAddress.isNotBlank() &amp;&amp; uiState.route == null) {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Button(&#10;                                onClick = { viewModel.calculateRoute() },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 8.dp),&#10;                                enabled = !uiState.isCalculatingRoute&#10;                            ) {&#10;                                if (uiState.isCalculatingRoute) {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(20.dp),&#10;                                        color = MaterialTheme.colorScheme.onPrimary,&#10;                                        strokeWidth = 2.dp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&quot;Calculating...&quot;)&#10;                                } else {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Navigation,&#10;                                        contentDescription = &quot;Calculate Route&quot;&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&quot;Calculate Route&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Clear Route button&#10;                        if (uiState.route != null) {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            OutlinedButton(&#10;                                onClick = { viewModel.clearRoute() },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 8.dp)&#10;                            ) {&#10;                                Text(&quot;Clear Route&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Bottom content: EV Dashboard and Route Info&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // EV Dashboard (always shown when battery state available)&#10;                uiState.batteryState?.let { batteryState: com.example.voltroute.domain.model.BatteryState -&gt;&#10;                    EvDashboard(&#10;                        batteryState = batteryState,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Route Info Card (shown when route calculated)&#10;                uiState.route?.let { route: com.example.voltroute.domain.model.Route -&gt;&#10;                    RouteInfoCard(&#10;                        route = route,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Loading indicator for location&#10;            if (uiState.isLoadingLocation) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.Center)&#10;                )&#10;            }&#10;&#10;            // Location error snackbar&#10;            uiState.locationError?.let { error -&gt;&#10;                Snackbar(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    action = {&#10;                        TextButton(onClick = viewModel::clearError) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(error)&#10;                }&#10;            }&#10;&#10;            // Route error snackbar&#10;            uiState.routeError?.let { error -&gt;&#10;                Snackbar(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    action = {&#10;                        TextButton(onClick = viewModel::clearRouteError) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(error)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.example.voltroute.presentation.map&#10;&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.EvStation&#10;import androidx.compose.material.icons.filled.Navigation&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.voltroute.domain.model.Charger&#10;import com.example.voltroute.domain.model.PowerLevel&#10;import com.example.voltroute.presentation.map.components.ChargerInfoCard&#10;import com.example.voltroute.presentation.map.components.DestinationInput&#10;import com.example.voltroute.presentation.map.components.EvDashboard&#10;import com.example.voltroute.presentation.map.components.RouteInfoCard&#10;import com.example.voltroute.presentation.map.components.getPowerLevelColor&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.LatLngBounds&#10;import com.google.maps.android.compose.*&#10;&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val vehicle by viewModel.vehicle.collectAsState()&#10;&#10;    // Request location permission&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        viewModel.onPermissionResult(isGranted)&#10;    }&#10;&#10;    // Request permission on first composition if not granted&#10;    LaunchedEffect(uiState.hasLocationPermission) {&#10;        if (!uiState.hasLocationPermission) {&#10;            permissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)&#10;        }&#10;    }&#10;&#10;    // Camera position for map&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            LatLng(uiState.currentLocation.latitude, uiState.currentLocation.longitude),&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Update camera when location changes (only if no route is displayed)&#10;    LaunchedEffect(uiState.currentLocation) {&#10;        if (uiState.route == null) {&#10;            cameraPositionState.position = CameraPosition.fromLatLngZoom(&#10;                LatLng(uiState.currentLocation.latitude, uiState.currentLocation.longitude),&#10;                12f&#10;            )&#10;        }&#10;    }&#10;&#10;    // Update camera to show full route when calculated&#10;    LaunchedEffect(uiState.route) {&#10;        uiState.route?.let { route -&gt;&#10;            if (uiState.routePoints.isNotEmpty()) {&#10;                // Create bounds that include all route points&#10;                val boundsBuilder = LatLngBounds.Builder()&#10;                uiState.routePoints.forEach { point -&gt;&#10;                    boundsBuilder.include(point)&#10;                }&#10;                val bounds = boundsBuilder.build()&#10;&#10;                // Animate camera to show full route with padding&#10;                val cameraUpdate = CameraUpdateFactory.newLatLngBounds(bounds, 100)&#10;                cameraPositionState.animate(cameraUpdate, 1000)&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;VoltRoute&quot;) },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    titleContentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Google Map&#10;            GoogleMap(&#10;                modifier = Modifier.fillMaxSize(),&#10;                cameraPositionState = cameraPositionState,&#10;                properties = MapProperties(&#10;                    isMyLocationEnabled = uiState.hasLocationPermission&#10;                ),&#10;                uiSettings = MapUiSettings(&#10;                    zoomControlsEnabled = false,&#10;                    myLocationButtonEnabled = true&#10;                )&#10;            ) {&#10;                // Current location marker&#10;                if (uiState.hasLocationPermission) {&#10;                    Marker(&#10;                        state = rememberMarkerState(&#10;                            position = LatLng(&#10;                                uiState.currentLocation.latitude,&#10;                                uiState.currentLocation.longitude&#10;                            )&#10;                        ),&#10;                        title = &quot;Current Location&quot;&#10;                    )&#10;                }&#10;&#10;                // Route polyline&#10;                if (uiState.routePoints.isNotEmpty()) {&#10;                    Polyline(&#10;                        points = uiState.routePoints,&#10;                        color = Color(0xFF2196F3), // Material Blue&#10;                        width = 12f&#10;                    )&#10;                }&#10;&#10;                // Destination marker&#10;                uiState.route?.let { route -&gt;&#10;                    Marker(&#10;                        state = rememberMarkerState(&#10;                            position = LatLng(&#10;                                route.endLocation.latitude,&#10;                                route.endLocation.longitude&#10;                            )&#10;                        ),&#10;                        title = &quot;Destination&quot;,&#10;                        snippet = route.endLocation.name,&#10;                        icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;                    )&#10;                }&#10;&#10;                // Charger markers (color-coded by power level)&#10;                if (uiState.showChargers) {&#10;                    uiState.chargers.forEach { charger -&gt;&#10;                        ChargerMarker(&#10;                            charger = charger,&#10;                            onClick = {&#10;                                viewModel.onChargerSelected(charger)&#10;                                true&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Destination input overlay&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.TopCenter)&#10;            ) {&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(8.dp)&#10;                    ) {&#10;                        DestinationInput(&#10;                            value = uiState.destinationAddress,&#10;                            onValueChange = viewModel::onDestinationChanged,&#10;                            enabled = uiState.hasLocationPermission&#10;                        )&#10;&#10;                        // Calculate Route button&#10;                        if (uiState.destinationAddress.isNotBlank() &amp;&amp; uiState.route == null) {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Button(&#10;                                onClick = { viewModel.calculateRoute() },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 8.dp),&#10;                                enabled = !uiState.isCalculatingRoute&#10;                            ) {&#10;                                if (uiState.isCalculatingRoute) {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(20.dp),&#10;                                        color = MaterialTheme.colorScheme.onPrimary,&#10;                                        strokeWidth = 2.dp&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&quot;Calculating...&quot;)&#10;                                } else {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Navigation,&#10;                                        contentDescription = &quot;Calculate Route&quot;&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(8.dp))&#10;                                    Text(&quot;Calculate Route&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Clear Route button&#10;                        if (uiState.route != null) {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            OutlinedButton(&#10;                                onClick = { viewModel.clearRoute() },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 8.dp)&#10;                            ) {&#10;                                Text(&quot;Clear Route&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Bottom content: EV Dashboard and Route Info&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // EV Dashboard (always shown when battery state available)&#10;                uiState.batteryState?.let { batteryState: com.example.voltroute.domain.model.BatteryState -&gt;&#10;                    EvDashboard(&#10;                        batteryState = batteryState,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Route Info Card (shown when route calculated)&#10;                uiState.route?.let { route: com.example.voltroute.domain.model.Route -&gt;&#10;                    RouteInfoCard(&#10;                        route = route,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Loading indicator for location&#10;            if (uiState.isLoadingLocation) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.Center)&#10;                )&#10;            }&#10;&#10;            // Location error snackbar&#10;            uiState.locationError?.let { error -&gt;&#10;                Snackbar(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    action = {&#10;                        TextButton(onClick = viewModel::clearError) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(error)&#10;                }&#10;            }&#10;&#10;            // Route error snackbar&#10;            uiState.routeError?.let { error -&gt;&#10;                Snackbar(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    action = {&#10;                        TextButton(onClick = viewModel::clearRouteError) {&#10;                            Text(&quot;Dismiss&quot;)&#10;                        }&#10;                    }&#10;                ) {&#10;                    Text(error)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/voltroute/presentation/map/MapViewModel_NEW.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/voltroute/presentation/map/MapViewModel_NEW.kt" />
              <option name="updatedContent" value="package com.example.voltroute.presentation.map&#10;&#10;import android.annotation.SuppressLint&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.voltroute.data.location.LocationClient&#10;import com.example.voltroute.domain.model.Location&#10;import com.example.voltroute.domain.model.Route&#10;import com.example.voltroute.domain.model.Vehicle&#10;import com.example.voltroute.domain.usecase.CalculateRouteUseCase&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.maps.android.PolyUtil&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class MapViewModel @Inject constructor(&#10;    private val locationClient: LocationClient,&#10;    private val calculateRouteUseCase: CalculateRouteUseCase&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(MapUiState())&#10;    val uiState: StateFlow&lt;MapUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _vehicle = MutableStateFlow(Vehicle())&#10;    val vehicle: StateFlow&lt;Vehicle&gt; = _vehicle.asStateFlow()&#10;&#10;    init {&#10;        checkLocationPermission()&#10;    }&#10;&#10;    private fun checkLocationPermission() {&#10;        val hasPermission = locationClient.hasLocationPermission()&#10;        _uiState.update { it.copy(hasLocationPermission = hasPermission) }&#10;&#10;        if (hasPermission) {&#10;            getCurrentLocation()&#10;        }&#10;    }&#10;&#10;    fun onPermissionResult(granted: Boolean) {&#10;        _uiState.update { it.copy(hasLocationPermission = granted) }&#10;        if (granted) {&#10;            getCurrentLocation()&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun getCurrentLocation() {&#10;        viewModelScope.launch  {&#10;            _uiState.update { it.copy(isLoadingLocation = true) }&#10;&#10;            val location = locationClient.getCurrentLocation()&#10;&#10;            _uiState.update {&#10;                it.copy(&#10;                    currentLocation = location ?: Location.DEFAULT,&#10;                    isLoadingLocation = false,&#10;                    locationError = if (location == null) &quot;Could not get location&quot; else null&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onDestinationChanged(destination: String) {&#10;        _uiState.update { it.copy(destinationAddress = destination) }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.update { it.copy(locationError = null) }&#10;    }&#10;&#10;    /**&#10;     * Calculate route from current location to destination&#10;     * &#10;     * Validates destination, calls use case, decodes polyline, and updates UI state&#10;     */&#10;    fun calculateRoute() {&#10;        viewModelScope.launch {&#10;            val destination = _uiState.value.destinationAddress&#10;            &#10;            // Validate destination is not blank&#10;            if (destination.isBlank()) {&#10;                _uiState.update { &#10;                    it.copy(routeError = &quot;Please enter a destination&quot;) &#10;                }&#10;                return@launch&#10;            }&#10;            &#10;            // Show loading state&#10;            _uiState.update { it.copy(isCalculatingRoute = true, routeError = null) }&#10;            &#10;            // Call use case to calculate route&#10;            val result = calculateRouteUseCase(&#10;                origin = _uiState.value.currentLocation,&#10;                destination = destination&#10;            )&#10;            &#10;            // Handle result&#10;            result.fold(&#10;                onSuccess = { route -&gt;&#10;                    // Decode polyline to LatLng points for map display&#10;                    val routePoints = try {&#10;                        PolyUtil.decode(route.polylinePoints)&#10;                    } catch (e: Exception) {&#10;                        emptyList()&#10;                    }&#10;                    &#10;                    _uiState.update {&#10;                        it.copy(&#10;                            route = route,&#10;                            routePoints = routePoints,&#10;                            isCalculatingRoute = false,&#10;                            routeError = null&#10;                        )&#10;                    }&#10;                },&#10;                onFailure = { exception -&gt;&#10;                    _uiState.update {&#10;                        it.copy(&#10;                            route = null,&#10;                            routePoints = emptyList(),&#10;                            isCalculatingRoute = false,&#10;                            routeError = exception.message ?: &quot;Could not calculate route&quot;&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear the current route and reset route-related state&#10;     */&#10;    fun clearRoute() {&#10;        _uiState.update {&#10;            it.copy(&#10;                route = null,&#10;                routePoints = emptyList(),&#10;                routeError = null&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Clear route error message&#10;     */&#10;    fun clearRouteError() {&#10;        _uiState.update { it.copy(routeError = null) }&#10;    }&#10;}&#10;&#10;data class MapUiState(&#10;    val currentLocation: Location = Location.DEFAULT,&#10;    val destinationAddress: String = &quot;&quot;,&#10;    val hasLocationPermission: Boolean = false,&#10;    val isLoadingLocation: Boolean = false,&#10;    val locationError: String? = null,&#10;    // Phase 2: Route calculation fields&#10;    val route: Route? = null,&#10;    val isCalculatingRoute: Boolean = false,&#10;    val routeError: String? = null,&#10;    val routePoints: List&lt;LatLng&gt; = emptyList()&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>